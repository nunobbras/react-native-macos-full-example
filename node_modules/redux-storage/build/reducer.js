'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _lodash = require('lodash.isfunction');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isobject');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.isarray');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.merge');

var _lodash8 = _interopRequireDefault(_lodash7);

var _immutable = require('immutable');

var _constants = require('./constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function myMerge(oldState, newState) {
    // Whole state is ImmutableJS? Easiest way to merge
    if ((0, _lodash2.default)(oldState.mergeDeep)) {
        return oldState.mergeDeep(newState);
    }

    // newState is ImmutableJS? We can safely use fromJS and merge
    if ((0, _lodash2.default)(newState.mergeDeep)) {
        return (0, _immutable.fromJS)(oldState).mergeDeep(newState);
    }

    // Otherwise we need to carefully merge to avoid deprecated warnings from
    // ImmutableJS see #8. We inspect only the first object level, as this is
    // a common pattern with redux!
    var result = _extends({}, oldState);
    // Note: Iterate using OLD STYLE and avoid Symbols for old browsers
    for (var key in newState) {
        if (!newState.hasOwnProperty(key)) {
            continue;
        }
        var value = newState[key];

        // Assign if we don't need to merge at all
        if (!result.hasOwnProperty(key)) {
            result[key] = (0, _lodash4.default)(value) && !(0, _lodash6.default)(value) ? (0, _lodash8.default)({}, value) : value;
            continue;
        }

        var oldValue = result[key];

        if (!!oldValue && (0, _lodash2.default)(oldValue.mergeDeep)) {
            result[key] = oldValue.mergeDeep(value);
        } else if (!!value && (0, _lodash2.default)(value.mergeDeep)) {
            result[key] = (0, _immutable.fromJS)(oldValue).mergeDeep(value);
        } else if ((0, _lodash4.default)(value) && !(0, _lodash6.default)(value)) {
            result[key] = (0, _lodash8.default)({}, oldValue, value);
        } else {
            result[key] = value;
        }
    }

    return result;
}

exports.default = function (reducer) {
    return function (state, action) {
        return reducer(action.type === _constants.LOAD ? myMerge(state, action.payload) : state, action);
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWR1Y2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVFBLFNBQVMsT0FBVCxDQUFpQixRQUFqQixFQUEyQixRQUEzQixFQUFxQzs7QUFFakMsUUFBSSxzQkFBVyxTQUFTLFNBQVQsQ0FBZixFQUFvQztBQUNoQyxlQUFPLFNBQVMsU0FBVCxDQUFtQixRQUFuQixDQUFQLENBRGdDO0tBQXBDOzs7QUFGaUMsUUFPN0Isc0JBQVcsU0FBUyxTQUFULENBQWYsRUFBb0M7QUFDaEMsZUFBTyx1QkFBTyxRQUFQLEVBQWlCLFNBQWpCLENBQTJCLFFBQTNCLENBQVAsQ0FEZ0M7S0FBcEM7Ozs7O0FBUGlDLFFBYzNCLHNCQUFjLFNBQWQ7O0FBZDJCLFNBZ0I1QixJQUFNLEdBQU4sSUFBYSxRQUFsQixFQUE0QjtBQUN4QixZQUFJLENBQUMsU0FBUyxjQUFULENBQXdCLEdBQXhCLENBQUQsRUFBK0I7QUFDL0IscUJBRCtCO1NBQW5DO0FBR0EsWUFBTSxRQUFRLFNBQVMsR0FBVCxDQUFSOzs7QUFKa0IsWUFPcEIsQ0FBQyxPQUFPLGNBQVAsQ0FBc0IsR0FBdEIsQ0FBRCxFQUE2QjtBQUM3QixtQkFBTyxHQUFQLElBQWMsc0JBQVMsS0FBVCxLQUFtQixDQUFDLHNCQUFRLEtBQVIsQ0FBRCxHQUMzQixzQkFBTSxFQUFOLEVBQVUsS0FBVixDQURRLEdBRVIsS0FGUSxDQURlO0FBSTdCLHFCQUo2QjtTQUFqQzs7QUFPQSxZQUFNLFdBQVcsT0FBTyxHQUFQLENBQVgsQ0Fka0I7O0FBZ0J4QixZQUFJLENBQUMsQ0FBQyxRQUFELElBQWEsc0JBQVcsU0FBUyxTQUFULENBQXpCLEVBQThDO0FBQzlDLG1CQUFPLEdBQVAsSUFBYyxTQUFTLFNBQVQsQ0FBbUIsS0FBbkIsQ0FBZCxDQUQ4QztTQUFsRCxNQUVPLElBQUksQ0FBQyxDQUFDLEtBQUQsSUFBVSxzQkFBVyxNQUFNLFNBQU4sQ0FBdEIsRUFBd0M7QUFDL0MsbUJBQU8sR0FBUCxJQUFjLHVCQUFPLFFBQVAsRUFBaUIsU0FBakIsQ0FBMkIsS0FBM0IsQ0FBZCxDQUQrQztTQUE1QyxNQUVBLElBQUksc0JBQVMsS0FBVCxLQUFtQixDQUFDLHNCQUFRLEtBQVIsQ0FBRCxFQUFpQjtBQUMzQyxtQkFBTyxHQUFQLElBQWMsc0JBQU0sRUFBTixFQUFVLFFBQVYsRUFBb0IsS0FBcEIsQ0FBZCxDQUQyQztTQUF4QyxNQUVBO0FBQ0gsbUJBQU8sR0FBUCxJQUFjLEtBQWQsQ0FERztTQUZBO0tBcEJYOztBQTJCQSxXQUFPLE1BQVAsQ0EzQ2lDO0NBQXJDOztrQkE4Q2UsVUFBQyxPQUFELEVBQWE7QUFDeEIsV0FBTyxVQUFDLEtBQUQsRUFBUSxNQUFSO2VBQW1CLFFBQ3RCLE9BQU8sSUFBUCx1QkFDTSxRQUFRLEtBQVIsRUFBZSxPQUFPLE9BQVAsQ0FEckIsR0FFTSxLQUZOLEVBR0EsTUFKc0I7S0FBbkIsQ0FEaUI7Q0FBYiIsImZpbGUiOiJyZWR1Y2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnbG9kYXNoLmlzZnVuY3Rpb24nO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJ2xvZGFzaC5pc29iamVjdCc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICdsb2Rhc2guaXNhcnJheSc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnbG9kYXNoLm1lcmdlJztcbmltcG9ydCB7IGZyb21KUyB9IGZyb20gJ2ltbXV0YWJsZSc7XG5cbmltcG9ydCB7IExPQUQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmZ1bmN0aW9uIG15TWVyZ2Uob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgLy8gV2hvbGUgc3RhdGUgaXMgSW1tdXRhYmxlSlM/IEVhc2llc3Qgd2F5IHRvIG1lcmdlXG4gICAgaWYgKGlzRnVuY3Rpb24ob2xkU3RhdGUubWVyZ2VEZWVwKSkge1xuICAgICAgICByZXR1cm4gb2xkU3RhdGUubWVyZ2VEZWVwKG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBuZXdTdGF0ZSBpcyBJbW11dGFibGVKUz8gV2UgY2FuIHNhZmVseSB1c2UgZnJvbUpTIGFuZCBtZXJnZVxuICAgIGlmIChpc0Z1bmN0aW9uKG5ld1N0YXRlLm1lcmdlRGVlcCkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KUyhvbGRTdGF0ZSkubWVyZ2VEZWVwKG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBjYXJlZnVsbHkgbWVyZ2UgdG8gYXZvaWQgZGVwcmVjYXRlZCB3YXJuaW5ncyBmcm9tXG4gICAgLy8gSW1tdXRhYmxlSlMgc2VlICM4LiBXZSBpbnNwZWN0IG9ubHkgdGhlIGZpcnN0IG9iamVjdCBsZXZlbCwgYXMgdGhpcyBpc1xuICAgIC8vIGEgY29tbW9uIHBhdHRlcm4gd2l0aCByZWR1eCFcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLm9sZFN0YXRlIH07XG4gICAgLy8gTm90ZTogSXRlcmF0ZSB1c2luZyBPTEQgU1RZTEUgYW5kIGF2b2lkIFN5bWJvbHMgZm9yIG9sZCBicm93c2Vyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghbmV3U3RhdGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGF0ZVtrZXldO1xuXG4gICAgICAgIC8vIEFzc2lnbiBpZiB3ZSBkb24ndCBuZWVkIHRvIG1lcmdlIGF0IGFsbFxuICAgICAgICBpZiAoIXJlc3VsdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICAgICAgICA/IG1lcmdlKHt9LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHJlc3VsdFtrZXldO1xuXG4gICAgICAgIGlmICghIW9sZFZhbHVlICYmIGlzRnVuY3Rpb24ob2xkVmFsdWUubWVyZ2VEZWVwKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvbGRWYWx1ZS5tZXJnZURlZXAodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCEhdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5tZXJnZURlZXApKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGZyb21KUyhvbGRWYWx1ZSkubWVyZ2VEZWVwKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCBvbGRWYWx1ZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChyZWR1Y2VyKSA9PiB7XG4gICAgcmV0dXJuIChzdGF0ZSwgYWN0aW9uKSA9PiByZWR1Y2VyKFxuICAgICAgICBhY3Rpb24udHlwZSA9PT0gTE9BRFxuICAgICAgICAgICAgPyBteU1lcmdlKHN0YXRlLCBhY3Rpb24ucGF5bG9hZClcbiAgICAgICAgICAgIDogc3RhdGUsXG4gICAgICAgIGFjdGlvblxuICAgICk7XG59O1xuIl19
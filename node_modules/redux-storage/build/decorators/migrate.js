'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = function (engine) {
    var currentVersion = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
    var key = arguments.length <= 2 || arguments[2] === undefined ? 'redux-storage-decorators-migrate-version' : arguments[2];

    var migrations = [];
    return _extends({}, engine, {
        load: function load() {
            return engine.load().then(function (state) {
                var fromVersion = state[key] || 0;
                var migratedState = state;

                var migrationsToApply = migrations.filter(function (migration) {
                    return migration.version > fromVersion && migration.version <= currentVersion;
                }).sort(function (m1, m2) {
                    return m2.version < m1.version;
                }).map(function (m) {
                    return m.migration;
                });

                migrationsToApply.forEach(function (migration) {
                    // Do nothing if migration returns nothing. Good for experiments.
                    // Migration isn't applied until it returns something.
                    migratedState = migration(migratedState) || migratedState;
                });

                // Version doesn't belong to app state, it's meta property.
                // Otherwise combineReducers would complain about missing reducer.
                delete migratedState[key];
                return migratedState;
            });
        },
        save: function save(state) {
            return engine.save(_extends({}, state, _defineProperty({}, key, currentVersion)));
        },
        // don't mutate the state
        addMigration: function addMigration(version, migration) {
            migrations.push({ version: version, migration: migration });
        }
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWNvcmF0b3JzL21pZ3JhdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztrQkFBZSxVQUFDLE1BQUQsRUFBa0Y7UUFBekUsdUVBQWlCLGlCQUF3RDtRQUFyRCw0REFBTSwwREFBK0M7O0FBQzdGLFFBQU0sYUFBYSxFQUFiLENBRHVGO0FBRTdGLHdCQUNPO0FBRUgsOEJBQU87QUFDSCxtQkFBTyxPQUFPLElBQVAsR0FBYyxJQUFkLENBQW1CLGlCQUFTO0FBQy9CLG9CQUFNLGNBQWMsTUFBTSxHQUFOLEtBQWMsQ0FBZCxDQURXO0FBRS9CLG9CQUFJLGdCQUFnQixLQUFoQixDQUYyQjs7QUFJL0Isb0JBQU0sb0JBQW9CLFdBQVcsTUFBWCxDQUFrQixxQkFBYTtBQUNyRCwyQkFBTyxVQUFVLE9BQVYsR0FBb0IsV0FBcEIsSUFBbUMsVUFBVSxPQUFWLElBQXFCLGNBQXJCLENBRFc7aUJBQWIsQ0FBbEIsQ0FFdkIsSUFGdUIsQ0FFbEIsVUFBQyxFQUFELEVBQUssRUFBTDsyQkFBWSxHQUFHLE9BQUgsR0FBYSxHQUFHLE9BQUg7aUJBQXpCLENBRmtCLENBRW1CLEdBRm5CLENBRXVCOzJCQUFLLEVBQUUsU0FBRjtpQkFBTCxDQUYzQyxDQUp5Qjs7QUFRL0Isa0NBQWtCLE9BQWxCLENBQTBCLHFCQUFhOzs7QUFHbkMsb0NBQWdCLFVBQVUsYUFBVixLQUE0QixhQUE1QixDQUhtQjtpQkFBYixDQUExQjs7OztBQVIrQix1QkFnQnhCLGNBQWMsR0FBZCxDQUFQLENBaEIrQjtBQWlCL0IsdUJBQU8sYUFBUCxDQWpCK0I7YUFBVCxDQUExQixDQURHOztBQXNCUCw0QkFBSyxPQUFPO0FBQ1IsbUJBQU8sT0FBTyxJQUFQLGNBQ0EsMkJBQ0YsS0FBTSxnQkFGSixDQUFQLENBRFE7OztBQU9aLDRDQUFhLFNBQVMsV0FBVztBQUM3Qix1QkFBVyxJQUFYLENBQWdCLEVBQUUsZ0JBQUYsRUFBVyxvQkFBWCxFQUFoQixFQUQ2Qjs7TUFoQ3JDLENBRjZGO0NBQWxGIiwiZmlsZSI6Im1pZ3JhdGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAoZW5naW5lLCBjdXJyZW50VmVyc2lvbiA9IDAsIGtleSA9ICdyZWR1eC1zdG9yYWdlLWRlY29yYXRvcnMtbWlncmF0ZS12ZXJzaW9uJykgPT4ge1xuICAgIGNvbnN0IG1pZ3JhdGlvbnMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbmdpbmUsXG5cbiAgICAgICAgbG9hZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmdpbmUubG9hZCgpLnRoZW4oc3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21WZXJzaW9uID0gc3RhdGVba2V5XSB8fCAwO1xuICAgICAgICAgICAgICAgIGxldCBtaWdyYXRlZFN0YXRlID0gc3RhdGU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBtaWdyYXRpb25zVG9BcHBseSA9IG1pZ3JhdGlvbnMuZmlsdGVyKG1pZ3JhdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtaWdyYXRpb24udmVyc2lvbiA+IGZyb21WZXJzaW9uICYmIG1pZ3JhdGlvbi52ZXJzaW9uIDw9IGN1cnJlbnRWZXJzaW9uO1xuICAgICAgICAgICAgICAgIH0pLnNvcnQoKG0xLCBtMikgPT4gbTIudmVyc2lvbiA8IG0xLnZlcnNpb24pLm1hcChtID0+IG0ubWlncmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIG1pZ3JhdGlvbnNUb0FwcGx5LmZvckVhY2gobWlncmF0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZyBpZiBtaWdyYXRpb24gcmV0dXJucyBub3RoaW5nLiBHb29kIGZvciBleHBlcmltZW50cy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWlncmF0aW9uIGlzbid0IGFwcGxpZWQgdW50aWwgaXQgcmV0dXJucyBzb21ldGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIG1pZ3JhdGVkU3RhdGUgPSBtaWdyYXRpb24obWlncmF0ZWRTdGF0ZSkgfHwgbWlncmF0ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFZlcnNpb24gZG9lc24ndCBiZWxvbmcgdG8gYXBwIHN0YXRlLCBpdCdzIG1ldGEgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIGNvbWJpbmVSZWR1Y2VycyB3b3VsZCBjb21wbGFpbiBhYm91dCBtaXNzaW5nIHJlZHVjZXIuXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1pZ3JhdGVkU3RhdGVba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWlncmF0ZWRTdGF0ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmUoc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmdpbmUuc2F2ZSh7XG4gICAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICAgICAgW2tleV06IGN1cnJlbnRWZXJzaW9uIC8vIGRvbid0IG11dGF0ZSB0aGUgc3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE1pZ3JhdGlvbih2ZXJzaW9uLCBtaWdyYXRpb24pIHtcbiAgICAgICAgICAgIG1pZ3JhdGlvbnMucHVzaCh7IHZlcnNpb24sIG1pZ3JhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIl19